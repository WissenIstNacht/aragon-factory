{
  "language": "Solidity",
  "sources": {
    "contracts/AragonFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.8;\n\nimport \"./vocdoni/token-storage-proof.sol\";\nimport \"./govern/GovernBaseFactory.sol\";\n\ncontract AragonFactory {\n    TokenStorageProof tokenProof;\n    GovernBaseFactory governBase;\n\n    constructor() public {\n        tokenProof = TokenStorageProof(\n            0xf215116795EE6add4789a8E891CAEB26A623221d\n        );\n        governBase = GovernBaseFactory(\n            0xe071Fc0C53Be275cF7246D16373A74231fA5a585\n        );\n    }\n\n    function test() public returns (string memory) {\n        return \"hola\";\n    }\n}\n"
    },
    "contracts/vocdoni/token-storage-proof.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"./vendor/openzeppelin/token/ERC20/IERC20.sol\";\nimport \"./common.sol\";\nimport \"./lib.sol\";\n\ncontract TokenStorageProof is ITokenStorageProof {\n    using RLP for bytes;\n    using RLP for RLP.RLPItem;\n    using TrieProof for bytes;\n\n    uint8 private constant ACCOUNT_STORAGE_ROOT_INDEX = 2;\n\n    string private constant ERROR_BLOCKHASH_NOT_AVAILABLE = \"BLOCKHASH_NOT_AVAILABLE\";\n    string private constant ERROR_INVALID_BLOCK_HEADER = \"INVALID_BLOCK_HEADER\";\n    string private constant ERROR_UNPROCESSED_STORAGE_ROOT = \"UNPROCESSED_STORAGE_ROOT\";\n    string private constant ERROR_NOT_A_CONTRACT = \"NOT_A_CONTRACT\";\n    string private constant ERROR_NOT_ENOUGH_FUNDS = \"NOT_ENOUGH_FUNDS\";\n    string private constant ERROR_ALREADY_REGISTERED = \"ALREADY_REGISTERED\";\n     string private constant ERROR_INVALID_ADDRESS = \"INVALID_ADDRESS\";\n\n    event TokenRegistered(address indexed token, address indexed registrar);\n\n    struct ERC20Token {\n        uint256 balanceMappingPosition;\n        bool registered;\n    }\n\n    mapping(address => ERC20Token) public tokens;\n    address[] public tokenAddresses;\n    uint32 public tokenCount = 0;\n\n    function isRegistered(address ercTokenAddress) public view override returns (bool) {\n        require(ercTokenAddress != address(0x0), ERROR_INVALID_ADDRESS);\n        return tokens[ercTokenAddress].registered;\n    }\n\n    function registerToken(\n        address tokenAddress,\n        uint256 balanceMappingPosition,\n        uint256 blockNumber,\n        bytes memory blockHeaderRLP,\n        bytes memory accountStateProof,\n        bytes memory storageProof\n    ) public override {\n        // Check that the address is a contract\n        require(\n            ContractSupport.isContract(tokenAddress),\n            ERROR_NOT_A_CONTRACT\n        );\n        // check token is not registered\n        require(!isRegistered(tokenAddress), ERROR_ALREADY_REGISTERED);\n\n        // check msg.sender balance calling 'balanceOf' function on the ERC20 contract\n        IERC20 tokenContract = IERC20(tokenAddress);\n        uint256 balance = tokenContract.balanceOf(msg.sender);\n        require(balance > 0, ERROR_NOT_ENOUGH_FUNDS);\n\n        bytes32 root = processStorageRoot(tokenAddress, blockNumber, blockHeaderRLP, accountStateProof);\n\n        uint256 balanceFromTrie = getBalance(\n            msg.sender,\n            storageProof,\n            root,\n            balanceMappingPosition\n        );\n        require(balanceFromTrie > 0, ERROR_NOT_ENOUGH_FUNDS);\n\n        ERC20Token storage newToken = tokens[tokenAddress];\n        newToken.registered = true;\n        newToken.balanceMappingPosition = balanceMappingPosition;\n        tokenAddresses.push(tokenAddress);\n        tokenCount = tokenCount + 1;\n\n        emit TokenRegistered(tokenAddress, msg.sender);\n    }\n\n    function processStorageRoot(\n        address tokenAddress,\n        uint256 blockNumber,\n        bytes memory blockHeaderRLP,\n        bytes memory accountStateProof\n    )\n        internal view returns (bytes32 accountStorageRoot)\n    {\n        bytes32 blockHash = blockhash(blockNumber);\n        // Before Constantinople only the most recent 256 block hashes are available\n        require(blockHash != bytes32(0), ERROR_BLOCKHASH_NOT_AVAILABLE);\n\n        // The path for an account in the state trie is the hash of its address\n        bytes32 accountProofPath = keccak256(abi.encodePacked(tokenAddress));\n\n        // Get the account state from a merkle proof in the state trie. Returns an RLP encoded bytes array\n        bytes32 stateRoot = _getStateRoot(blockHeaderRLP, blockHash);\n        bytes memory accountRLP = accountStateProof.verify(stateRoot, accountProofPath);\n\n        // Extract the storage root from the account node and convert to bytes32\n        accountStorageRoot = bytes32(accountRLP.toRLPItem().toList()[ACCOUNT_STORAGE_ROOT_INDEX].toUint());\n    }\n\n    function getBalance(\n        address holder,\n        bytes memory storageProof,\n        bytes32 root,\n        uint256 balanceMappingPosition\n    )\n        internal pure returns (uint256)\n    {\n        require(root != bytes32(0), ERROR_UNPROCESSED_STORAGE_ROOT);\n        // The path for a storage value is the hash of its slot\n        bytes32 slot = getHolderBalanceSlot(holder, balanceMappingPosition);\n        bytes32 storageProofPath = keccak256(abi.encodePacked(slot));\n\n        bytes memory value;\n        value = TrieProof.verify(storageProof, root, storageProofPath);\n\n        return value.toRLPItem().toUint();\n    }\n\n    function getHolderBalanceSlot(address holder, uint256 balanceMappingPosition) public pure override returns (bytes32) {\n        return keccak256(abi.encodePacked(bytes32(uint256(holder)), balanceMappingPosition));\n    }\n\n\n    function getBalanceMappingPosition(address tokenAddress) public view override returns (uint256) {\n        require(tokenAddress != address(0x0), ERROR_INVALID_ADDRESS);\n        return tokens[tokenAddress].balanceMappingPosition;\n    }\n\n    /**\n    * @dev Extract state root from block header, verifying block hash\n    */\n    function _getStateRoot(bytes memory blockHeaderRLP, bytes32 blockHash) internal pure returns (bytes32 stateRoot) {\n        require(blockHeaderRLP.length > 123, ERROR_INVALID_BLOCK_HEADER); // prevent from reading invalid memory\n        require(keccak256(blockHeaderRLP) == blockHash, ERROR_INVALID_BLOCK_HEADER);\n        // 0x7b = 0x20 (length) + 0x5b (position of state root in header, [91, 123])\n        assembly { stateRoot := mload(add(blockHeaderRLP, 0x7b)) }\n    }\n}\n"
    },
    "contracts/govern/GovernBaseFactory.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"./govern-token/GovernTokenFactory.sol\";\nimport \"../vocdoni/vendor/openzeppelin/token/ERC20/IERC20.sol\";\n\nimport \"./pipelines/GovernQueue.sol\";\nimport \"./GovernRegistry.sol\";\nimport \"./core-factories/GovernFactory.sol\";\nimport \"./core-factories/GovernQueueFactory.sol\";\n\n\ncontract GovernBaseFactory {\n    address internal constant ANY_ADDR = address(-1);\n\n    GovernFactory public governFactory;\n    GovernQueueFactory public queueFactory;\n    GovernTokenFactory public tokenFactory;\n    GovernRegistry public registry;\n\n    constructor(\n        GovernRegistry _registry,\n        GovernFactory _governFactory,\n        GovernQueueFactory _queueFactory,\n        GovernTokenFactory _tokenFactory\n    ) public {\n        governFactory = _governFactory;\n        queueFactory = _queueFactory;\n        tokenFactory = _tokenFactory;\n        registry = _registry;\n    }\n\n    function newGovernWithoutConfig(\n        string calldata _name,\n        IERC20 _token,\n        string calldata _tokenName,\n        string calldata _tokenSymbol,\n        bool _useProxies\n    ) external returns (Govern govern, GovernQueue queue) {\n        bytes32 salt =\n            _useProxies ? keccak256(abi.encodePacked(_name)) : bytes32(0);\n\n        queue = queueFactory.newQueue(address(this), dummyConfig(), salt);\n        govern = governFactory.newGovern(queue, salt);\n\n        if (address(_token) == address(0)) {\n            (_token, ) = tokenFactory.newToken(\n                govern,\n                _tokenName,\n                _tokenSymbol,\n                18, // NOTE: hardcoding due to stack to deep issues\n                msg.sender,\n                1 * 10**18,\n                _useProxies\n            );\n        }\n\n        registry.register(govern, queue, _token, _name, \"\");\n\n        ACLData.BulkItem[] memory items = new ACLData.BulkItem[](6);\n        items[0] = ACLData.BulkItem(\n            ACLData.BulkOp.Grant,\n            queue.schedule.selector,\n            ANY_ADDR\n        );\n        items[1] = ACLData.BulkItem(\n            ACLData.BulkOp.Grant,\n            queue.execute.selector,\n            ANY_ADDR\n        );\n        items[2] = ACLData.BulkItem(\n            ACLData.BulkOp.Grant,\n            queue.challenge.selector,\n            ANY_ADDR\n        );\n        items[3] = ACLData.BulkItem(\n            ACLData.BulkOp.Grant,\n            queue.configure.selector,\n            address(govern)\n        );\n        items[4] = ACLData.BulkItem(\n            ACLData.BulkOp.Revoke,\n            queue.ROOT_ROLE(),\n            address(this)\n        );\n        items[5] = ACLData.BulkItem(\n            ACLData.BulkOp.Freeze,\n            queue.ROOT_ROLE(),\n            address(0)\n        );\n\n        queue.bulk(items);\n    }\n\n    function dummyConfig() internal pure returns (ERC3000Data.Config memory) {\n        ERC3000Data.Collateral memory noCollateral;\n        return\n            ERC3000Data.Config(0, noCollateral, noCollateral, address(0), \"\");\n    }\n}\n"
    },
    "contracts/vocdoni/vendor/openzeppelin/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/vocdoni/common.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity >=0.6.0 <0.7.0;\npragma experimental ABIEncoderV2;\n\n/// @notice The `IProcessStore` interface allows different versions of the contract to talk to each other. Not all methods in the contract need to be future proof.\n/// @notice Should operations be updated, then two versions should be kept, one for the old version and one for the new.\ninterface IProcessStore {\n    enum Status {READY, ENDED, CANCELED, PAUSED, RESULTS}\n\n    // GET\n    function getEntityProcessCount(address entityAddress) external view returns (uint256);\n    function getNextProcessId(address entityAddress) external view returns (bytes32);\n    function getProcessId(address entityAddress, uint256 processCountIndex, uint32 namespaceId, uint32 chainId) external pure returns (bytes32);\n    function get(bytes32 processId) external view returns (\n        uint8[3] memory mode_envelopeType_censusOrigin,\n        address entityAddress,\n        string[3] memory metadata_censusRoot_censusUri,\n        uint32[2] memory startBlock_blockCount,\n        Status status,\n        uint8[5] memory questionIndex_questionCount_maxCount_maxValue_maxVoteOverwrites,\n        uint16[2] memory maxTotalCost_costExponent,\n        uint256 evmBlockHeight // EVM only\n    );\n    function getParamsSignature(bytes32 processId) external view returns (bytes32);\n    function getCreationInstance(bytes32 processId) external view returns (address);\n\n    // SET\n    function newProcess(\n        uint8[3] calldata mode_envelopeType_censusOrigin,\n        address tokenContractAddress,\n        string[3] calldata metadata_censusRoot_censusUri,\n        uint32[2] calldata startBlock_blockCount,\n        uint8[4] calldata questionCount_maxCount_maxValue_maxVoteOverwrites,\n        uint16[2] calldata maxTotalCost_costExponent,\n        uint256 evmBlockHeight, // EVM only\n        bytes32 paramsSignature\n    ) payable external;\n    function setStatus(bytes32 processId, Status newStatus) external;\n    function incrementQuestionIndex(bytes32 processId) external;\n    function setCensus(bytes32 processId, string calldata censusRoot, string calldata censusUri) external;\n    function setProcessPrice(uint256 processPrice) external;\n    function withdraw(address payable to, uint256 amount) external;\n\n    // EVENTS\n    event NewProcess(bytes32 processId, uint32 namespace);\n    event StatusUpdated(bytes32 processId, uint32 namespace, Status status);\n    event QuestionIndexUpdated(\n        bytes32 processId,\n        uint32 namespace,\n        uint8 newIndex\n    );\n    event CensusUpdated(bytes32 processId, uint32 namespace);\n    event ProcessPriceUpdated(uint256 processPrice);\n    event Withdraw(address to, uint256 amount);\n}\n\n/// @notice The `IResultsStore` interface allows different versions of the contract to talk to each other. Not all methods in the contract need to be future proof.\n/// @notice Should operations be updated, then two versions should be kept, one for the old version and one for the new.\ninterface IResultsStore {\n    modifier onlyOracle(uint32 vochainId) virtual;\n\n    // GET\n    function getResults(bytes32 processId) external view returns (uint32[][] memory tally, uint32 height);\n\n    // SET\n    function setProcessesAddress(address processesAddr) external;\n    function setResults(bytes32 processId, uint32[][] calldata tally, uint32 height, uint32 vochainId) external;\n\n    // EVENTS\n    event ResultsAvailable(bytes32 processId);\n}\n\n/// @notice The `INamespaceStore` interface defines the contract methods that allow process contracts to self register to a namespace ID\ninterface INamespaceStore {\n    // SETTERS\n    function register() external returns(uint32);\n\n    // GETTERS\n    function processContractAt(uint32 namespaceId) external view returns (address);\n\n    // EVENTS\n    event NamespaceRegistered(uint32 namespace);\n}\n\n/// @notice The `IGenesisStore` interface defines the standard methods that allow querying and updating the details of each namespace.\ninterface IGenesisStore {\n    // SETTERS\n    function newChain(string calldata genesis, bytes[] calldata validators, address[] calldata oracles) external returns (uint32);\n    function setGenesis(uint32 chainId, string calldata newGenesis) external;\n    function addValidator(uint32 chainId, bytes calldata validatorPublicKey) external;\n    function removeValidator(uint32 chainId, uint256 idx, bytes calldata validatorPublicKey) external;\n    function addOracle(uint32 chainId, address oracleAddress) external;\n    function removeOracle(uint32 chainId, uint256 idx, address oracleAddress) external;\n\n    // GETTERS\n    function get(uint32 chainId) view external returns ( string memory genesis, bytes[] memory validators, address[] memory oracles);\n    function isValidator(uint32 chainId, bytes calldata validatorPublicKey) external view returns (bool);\n    function isOracle(uint32 chainId, address oracleAddress) external view returns (bool);\n    function getChainCount() external view returns(uint32);\n\n    // EVENTS\n    event ChainRegistered(uint32 chainId);\n    event GenesisUpdated(uint32 chainId);\n    event ValidatorAdded(uint32 chainId, bytes validatorPublicKey);\n    event ValidatorRemoved(uint32 chainId, bytes validatorPublicKey);\n    event OracleAdded(uint32 chainId, address oracleAddress);\n    event OracleRemoved(uint32 chainId, address oracleAddress);\n}\n\n/// @notice The `ITokenStorageProof` interface defines the standard methods that allow checking ERC token balances.\ninterface ITokenStorageProof {\n    /// @notice Checks that the given contract is an ERC token, validates that the balance of the sender matches the one obtained from the storage position and registers the token address\n    function registerToken(\n        address tokenAddress,\n        uint256 balanceMappingPosition,\n        uint256 blockNumber,\n        bytes calldata blockHeaderRLP,\n        bytes calldata accountStateProof,\n        bytes calldata storageProof) external;\n\n    /// @notice Determines whether the given address is registered as an ERC token contract\n    function isRegistered(address tokenAddress) external view returns (bool);\n  \n    /// @notice Determines the balance slot of a holder of an ERC20 token given a balance slot\n    function getHolderBalanceSlot(address holder, uint256 balanceMappingPosition) external pure returns(bytes32);\n\n    /// @notice Returns the balance mapping position of a token for users to generate proofs\n    function getBalanceMappingPosition(address tokenAddress) external view returns (uint256);\n}\n"
    },
    "contracts/vocdoni/lib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity >=0.6.0 <0.7.0;\n\n\nlibrary SafeUint8 {\n    /// @notice Adds two uint8 integers and fails if an overflow occurs\n    function add8(uint8 a, uint8 b) internal pure returns (uint8) {\n        uint8 c = a + b;\n        require(c >= a, \"overflow\");\n\n        return c;\n    }\n}\n\n\nlibrary ContractSupport {\n    // Compatible contract functions signatures\n    bytes4 private constant BALANCE_OF_ADDR = bytes4(\n        keccak256(\"balanceOf(address)\")\n    );\n\n    function isContract(address targetAddress) internal view returns (bool) {\n        uint256 size;\n        if (targetAddress == address(0)) return false;\n        assembly {\n            size := extcodesize(targetAddress)\n        }\n        return size > 0;\n    }\n\n    function isSupporting(address targetAddress, bytes memory data)\n        private\n        returns (bool)\n    {\n        bool success;\n        assembly {\n            success := call(\n                gas(), // gas remaining\n                targetAddress, // destination address\n                0, // no ether\n                add(data, 32), // input buffer (starts after the first 32 bytes in the `data` array)\n                mload(data), // input length (loaded from the first 32 bytes in the `data` array)\n                0, // output buffer\n                0 // output length\n            )\n        }\n        return success;\n    }\n\n    function supportsBalanceOf(address targetAddress) internal returns (bool) {\n        bytes memory data = abi.encodeWithSelector(\n            BALANCE_OF_ADDR,\n            address(0x0)\n        );\n        return isSupporting(targetAddress, data);\n    }\n}\n\n/**\n* @author Hamdi Allam hamdi.allam97@gmail.com\n* Please reach out with any questions or concerns\n*/\nlibrary RLP {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START  = 0xb8;\n    uint8 constant LIST_SHORT_START   = 0xc0;\n    uint8 constant LIST_LONG_START    = 0xf8;\n\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1, \"Invalid RLPItem. Booleans are encoded in 1 byte\");\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        return result == 0 ? false : true;\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix according to RLP spec\n        require(item.len <= 21, \"Invalid RLPItem. Addresses are encoded in 20 bytes or less\");\n\n        return address(toUint(item));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 len = item.len - offset;\n        uint256 memPtr = item.memPtr + offset;\n\n        uint256 result;\n        assembly {\n            result := div(mload(memPtr), exp(256, sub(32, len))) // shift to the correct location\n        }\n\n        return result;\n    }\n\n    function toRLPBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        _copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 len = item.len - offset; // data length\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        _copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    function toRLPItem(bytes memory item) internal pure returns (RLPItem memory) {\n        if (item.length == 0)\n            return RLPItem(0, 0);\n\n        uint256 memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory result) {\n        require(isList(item), \"Cannot convert to list a non-list RLPItem.\");\n\n        uint256 items = numItems(item);\n        result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n    }\n\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START)\n            return false;\n        return true;\n    }\n\n    function numItems(RLPItem memory item) internal pure returns (uint256) {\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    function _itemLength(uint256 memPtr) private pure returns (uint256 len) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            return 1;\n        } else if (byte0 < STRING_LONG_START) {\n            return byte0 - STRING_SHORT_START + 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n            /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                len := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 < LIST_LONG_START) {\n            return byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                len := add(dataLen, add(byteLen, 1))\n            }\n        }\n    }\n\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            return 0;\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\n            return 1;\n        } else if (byte0 < LIST_SHORT_START) {  // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        } else {\n            return byte0 - (LIST_LONG_START - 1) + 1;\n        }\n    }\n\n    // solium-disable security/no-assign-params\n    function _copy(uint256 src, uint256 dest, uint256 len) private pure {\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint256 mask = 256 ** (WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n\nlibrary TrieProof {\n    using RLP for RLP.RLPItem;\n    using RLP for bytes;\n\n    bytes32 internal constant EMPTY_TRIE_ROOT_HASH = 0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421;\n\n    // decoding from compact encoding (hex prefix encoding on the yellow paper)\n    function decodeNibbles(bytes memory compact, uint256 skipNibbles)\n    internal\n    pure\n    returns (bytes memory nibbles)\n    {\n        require(compact.length > 0); // input > 0\n\n        uint256 length = compact.length * 2; // need bytes, compact uses nibbles\n        require(skipNibbles <= length);\n        length -= skipNibbles;\n\n        nibbles = new bytes(length);\n        uint256 nibblesLength = 0;\n\n        for (uint256 i = skipNibbles; i < skipNibbles + length; i += 1) {\n            if (i % 2 == 0) {\n                nibbles[nibblesLength] = bytes1(\n                    (uint8(compact[i / 2]) >> 4) & 0xF\n                );\n            } else {\n                nibbles[nibblesLength] = bytes1(\n                    (uint8(compact[i / 2]) >> 0) & 0xF\n                );\n            }\n            nibblesLength += 1;\n        }\n\n        assert(nibblesLength == nibbles.length);\n    }\n\n    function merklePatriciaCompactDecode(bytes memory compact)\n    internal\n    pure\n    returns (bool isLeaf, bytes memory nibbles)\n    {\n        require(compact.length > 0, \"Empty\");\n\n        uint256 first_nibble = (uint8(compact[0]) >> 4) & 0xF;\n        uint256 skipNibbles;\n\n        if (first_nibble == 0) {\n            skipNibbles = 2;\n            isLeaf = false;\n        } else if (first_nibble == 1) {\n            skipNibbles = 1;\n            isLeaf = false;\n        } else if (first_nibble == 2) {\n            skipNibbles = 2;\n            isLeaf = true;\n        } else if (first_nibble == 3) {\n            skipNibbles = 1;\n            isLeaf = true;\n        } else {\n            // Not supposed to happen!\n            revert(\"failed decoding Trie\");\n        }\n\n        return (isLeaf, decodeNibbles(compact, skipNibbles));\n    }\n\n    function isEmptyByteSequence(RLP.RLPItem memory item)\n    internal\n    pure\n    returns (bool)\n    {\n        if (item.len != 1) {\n            return false;\n        }\n        uint8 b;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            b := byte(0, mload(memPtr))\n        }\n        return b == 0x80; /* empty byte string */\n    }\n\n    function sharedPrefixLength(\n        uint256 xsOffset,\n        bytes memory xs,\n        bytes memory ys\n    ) internal pure returns (uint256) {\n        uint256 i;\n        for (i = 0; i + xsOffset < xs.length && i < ys.length; i++) {\n            if (xs[i + xsOffset] != ys[i]) {\n                return i;\n            }\n        }\n        return i;\n    }\n\n    /// @dev Computes the hash of the Merkle-Patricia-Trie hash of the input.\n    ///      Merkle-Patricia-Tries use a hash function that outputs\n    ///      *variable-length* hashes: If the input is shorter than 32 bytes,\n    ///      the MPT hash is the input. Otherwise, the MPT hash is the\n    ///      Keccak-256 hash of the input.\n    ///      The easiest way to compare variable-length byte sequences is\n    ///      to compare their Keccak-256 hashes.\n    /// @param input The byte sequence to be hashed.\n    /// @return Keccak-256(MPT-hash(input))\n    function mptHashHash(bytes memory input) internal pure returns (bytes32) {\n        if (input.length < 32) {\n            return keccak256(input);\n        } else {\n            return\n            keccak256(abi.encodePacked(keccak256(abi.encodePacked(input))));\n        }\n    }\n\n    /// @dev Validates a Merkle-Patricia-Trie proof.\n    ///      If the proof proves the inclusion of some key-value pair in the\n    ///      trie, the value is returned. Otherwise, i.e. if the proof proves\n    ///      the exclusion of a key from the trie, an empty byte array is\n    ///      returned.\n    /// @param siblings is the stack of MPT nodes (starting with the root) that need to be traversed during verification.\n    /// @param rootHash is the Keccak-256 hash of the root node of the MPT\n    /// @param key is the key of the node whose inclusion/exclusion we are proving.\n    /// @return value whose inclusion is proved or an empty byte array for a proof of exclusion\n    function verify(\n        bytes memory siblings, // proofs\n        bytes32 rootHash,\n        bytes32 key\n    ) internal pure returns (bytes memory value) {\n        // copy key for convenience\n        bytes memory decoded_key = new bytes(32);\n        assembly {\n            mstore(add(decoded_key, 0x20), key)\n        }\n        // key consisting on nibbles\n        decoded_key = decodeNibbles(decoded_key, 0);\n\n        // siblings to RLP encoding list\n        RLP.RLPItem[] memory rlpSiblings = siblings.toRLPItem().toList();\n        bytes memory rlpNode;\n        bytes32 nodeHashHash;\n        RLP.RLPItem[] memory node;\n        RLP.RLPItem memory rlpValue;\n\n        uint256 keyOffset = 0; // Offset of the proof\n\n        // if not siblings the root hash is the hash of an empty trie\n        if (rlpSiblings.length == 0) {\n            // Root hash of empty tx trie\n            require(rootHash == EMPTY_TRIE_ROOT_HASH, \"Bad empty proof\");\n            return new bytes(0);\n        }\n\n        // Traverse stack of nodes starting at root.\n        for (uint256 i = 0; i < rlpSiblings.length; i++) {\n            // We use the fact that an rlp encoded list consists of some\n            // encoding of its length plus the concatenation of its\n            // *rlp-encoded* items.\n            rlpNode = rlpSiblings[i].toRLPBytes();\n\n            // The root node is hashed with Keccak-256\n            if (i == 0 && rootHash != keccak256(rlpNode)) {\n                revert(\"bad first proof part\");\n            }\n            // All other nodes are hashed with the MPT hash function.\n            if (i != 0 && nodeHashHash != mptHashHash(rlpNode)) {\n                revert(\"bad hash\");\n            }\n\n            node = rlpSiblings[i].toList();\n\n            // Extension or Leaf node\n            if (node.length == 2) {\n                bool isLeaf;\n                bytes memory nodeKey;\n                (isLeaf, nodeKey) = merklePatriciaCompactDecode(\n                    node[0].toBytes()\n                );\n\n                uint256 prefixLength = sharedPrefixLength(\n                    keyOffset,\n                    decoded_key,\n                    nodeKey\n                );\n                keyOffset += prefixLength;\n\n                if (prefixLength < nodeKey.length) {\n                    // Proof claims divergent extension or leaf. (Only\n                    // relevant for proofs of exclusion.)\n                    // An Extension/Leaf node is divergent if it \"skips\" over\n                    // the point at which a Branch node should have been had the\n                    // excluded key been included in the trie.\n                    // Example: Imagine a proof of exclusion for path [1, 4],\n                    // where the current node is a Leaf node with\n                    // path [1, 3, 3, 7]. For [1, 4] to be included, there\n                    // should have been a Branch node at [1] with a child\n                    // at 3 and a child at 4.\n\n                    // Sanity check\n                    if (i < rlpSiblings.length - 1) {\n                        // divergent node must come last in proof\n                        revert(\"divergent node must come last in proof\");\n                    }\n                    return new bytes(0);\n                }\n\n                if (isLeaf) {\n                    // Sanity check\n                    if (i < rlpSiblings.length - 1) {\n                        // leaf node must come last in proof\n                        revert(\"leaf must come last in proof\");\n                    }\n\n                    if (keyOffset < decoded_key.length) {\n                        return new bytes(0);\n                    }\n\n                    rlpValue = node[1];\n                    return rlpValue.toBytes();\n                } else {\n                    // extension node\n                    // Sanity check\n                    if (i == rlpSiblings.length - 1) {\n                        // should not be at last level\n                        revert(\"extension node cannot be at last level\");\n                    }\n\n                    if (!node[1].isList()) {\n                        // rlp(child) was at least 32 bytes. node[1] contains\n                        // Keccak256(rlp(child)).\n                        nodeHashHash = keccak256(node[1].toBytes());\n                    } else {\n                        // rlp(child) was at less than 32 bytes. node[1] contains\n                        // rlp(child).\n                        nodeHashHash = keccak256(node[1].toRLPBytes());\n                    }\n                }\n            } else if (node.length == 17) {\n                // Branch node\n                if (keyOffset != decoded_key.length) {\n                    // we haven't consumed the entire path, so we need to look at a child\n                    uint8 nibble = uint8(decoded_key[keyOffset]);\n                    keyOffset += 1;\n                    if (nibble >= 16) {\n                        // each element of the path has to be a nibble\n                        revert(\"if branch node each element has to be a nibble\");\n                    }\n\n                    if (isEmptyByteSequence(node[nibble])) {\n                        // Sanity\n                        if (i != rlpSiblings.length - 1) {\n                            // leaf node should be at last level\n                            revert(\"leaf nodes only at last level\");\n                        }\n                        return new bytes(0);\n                    } else if (!node[nibble].isList()) {\n                        nodeHashHash = keccak256(node[nibble].toBytes());\n                    } else {\n                        nodeHashHash = keccak256(node[nibble].toRLPBytes());\n                    }\n                } else {\n                    // we have consumed the entire mptKey, so we need to look at what's contained in this node.\n                    // Sanity\n\n                    if (i != rlpSiblings.length - 1) {\n                        // should be at last level\n                        revert(\"should be at last level\");\n                    }\n                    return node[16].toBytes();\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/govern/govern-token/GovernTokenFactory.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"@aragon/govern-contract-utils/contracts/minimal-proxies/ERC1167ProxyFactory.sol\";\nimport \"../erc3k/IERC3000Executor.sol\";\n\nimport \"./GovernToken.sol\";\nimport \"./GovernMinter.sol\";\nimport \"./MerkleDistributor.sol\";\n\ncontract GovernTokenFactory {\n    using ERC1167ProxyFactory for address;\n    \n    address public tokenBase;\n    address public minterBase;\n    address public distributorBase;\n\n    event CreatedToken(GovernToken token, GovernMinter minter);\n\n    constructor() public {\n        setupBases();\n    }\n\n    function newToken(\n        IERC3000Executor _governExecutor,\n        string calldata _tokenName,\n        string calldata _tokenSymbol,\n        uint8 _tokenDecimals,\n        address _mintAddr,\n        uint256 _mintAmount,\n        bool _useProxies\n    ) external returns (\n        GovernToken token,\n        GovernMinter minter\n    ) {\n        if (!_useProxies) {\n            (token, minter) = _deployContracts(_tokenName, _tokenSymbol, _tokenDecimals);\n        } else {\n            token = GovernToken(tokenBase.clone(abi.encodeWithSelector(\n                token.initialize.selector,\n                address(this),\n                _tokenName,\n                _tokenSymbol,\n                _tokenDecimals\n            ))); \n            minter = GovernMinter(minterBase.clone(abi.encodeWithSelector(\n                minter.initialize.selector,\n                token,\n                address(this),\n                MerkleDistributor(distributorBase)\n            )));\n        }\n\n        token.changeMinter(address(minter));\n        if (_mintAmount > 0) minter.mint(_mintAddr, _mintAmount, \"initial mint\");\n\n        bytes4 mintRole = minter.mint.selector ^ minter.merkleMint.selector;\n        bytes4 rootRole = minter.ROOT_ROLE();\n\n        ACLData.BulkItem[] memory items = new ACLData.BulkItem[](4);\n\n        items[0] = ACLData.BulkItem(ACLData.BulkOp.Grant, mintRole, address(_governExecutor));\n        items[1] = ACLData.BulkItem(ACLData.BulkOp.Grant, rootRole, address(_governExecutor));\n        items[2] = ACLData.BulkItem(ACLData.BulkOp.Revoke, mintRole, address(this));\n        items[3] = ACLData.BulkItem(ACLData.BulkOp.Revoke, rootRole, address(this));\n\n        minter.bulk(items);\n\n        emit CreatedToken(token, minter);\n    }\n\n    function setupBases() private {\n        distributorBase = address(new MerkleDistributor(ERC20(tokenBase), bytes32(0)));\n        \n        (GovernToken token, GovernMinter minter) = _deployContracts(\n            \"GovernToken base\",\n            \"GTB\",\n            0\n        );\n        token.changeMinter(address(minter));\n\n        // test the bases\n        minter.mint(msg.sender, 1, \"test mint\");\n        minter.merkleMint(bytes32(0), 1, \"no tree\", \"test merkle mint\");\n\n        // store bases\n        tokenBase = address(token);\n        minterBase = address(minter);\n    }\n\n    function _deployContracts(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        uint8 _tokenDecimals\n    ) internal returns (\n        GovernToken token,\n        GovernMinter minter\n    ) {\n        token = new GovernToken(address(this), _tokenName, _tokenSymbol, _tokenDecimals);\n        minter = new GovernMinter(GovernToken(token), address(this), MerkleDistributor(distributorBase));\n    }\n}\n"
    },
    "contracts/govern/pipelines/GovernQueue.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2; // required for passing structs in calldata (fairly secure at this point)\n\nimport \"@aragon/govern-contract-utils/contracts/acl/ACL.sol\";\nimport \"@aragon/govern-contract-utils/contracts/adaptative-erc165/AdaptativeERC165.sol\";\nimport \"../../vocdoni/vendor/openzeppelin/token/ERC20/SafeERC20.sol\";\nimport \"../../vocdoni/vendor/openzeppelin/math/SafeMath.sol\";\n\nimport \"../erc3k/IERC3000.sol\";\nimport \"../protocol/IArbitrable.sol\";\nimport \"../protocol/IArbitrator.sol\";\nimport \"../utils/DepositLib.sol\";\n\nlibrary GovernQueueStateLib {\n    enum State {\n        None,\n        Scheduled,\n        Challenged,\n        Approved,\n        Rejected,\n        Cancelled,\n        Executed\n    }\n\n    struct Item {\n        State state;\n    }\n\n    function checkState(Item storage _item, State _requiredState)\n        internal\n        view\n    {\n        require(_item.state == _requiredState, \"queue: bad state\");\n    }\n\n    function setState(Item storage _item, State _state) internal {\n        _item.state = _state;\n    }\n\n    function checkAndSetState(\n        Item storage _item,\n        State _fromState,\n        State _toState\n    ) internal {\n        checkState(_item, _fromState);\n        setState(_item, _toState);\n    }\n}\n\ncontract GovernQueue is IERC3000, IArbitrable, AdaptativeERC165, ACL {\n    // Syntax sugar to enable method-calling syntax on types\n    using ERC3000Data for *;\n    using DepositLib for ERC3000Data.Collateral;\n    using GovernQueueStateLib for GovernQueueStateLib.Item;\n    using SafeERC20 for ERC20;\n    using SafeMath for uint256;\n\n    // Map '4' as the 'allow' ruling; this implicitly maps '3' as the 'reject' ruling\n    uint256 internal constant ALLOW_RULING = 4;\n\n    // Permanent state\n    bytes32 public configHash; // keccak256 hash of the current ERC3000Data.Config\n    uint256 public nonce; // number of scheduled payloads so far\n    mapping(bytes32 => GovernQueueStateLib.Item) public queue; // container hash -> execution state\n\n    // Temporary state\n    mapping(bytes32 => address) public challengerCache; // container hash -> challenger addr (used after challenging and before dispute resolution)\n    mapping(bytes32 => mapping(IArbitrator => uint256)) public disputeItemCache; // container hash -> arbitrator addr -> dispute id (used between dispute creation and ruling)\n\n    /**\n     * @param _aclRoot account that will be given root permissions on ACL (commonly given to factory)\n     * @param _initialConfig initial configuration parameters\n     */\n    constructor(address _aclRoot, ERC3000Data.Config memory _initialConfig)\n        public\n        ACL(_aclRoot) // note that this contract directly derives from ACL (ACL is local to contract and not global to system in Govern)\n    {\n        initialize(_aclRoot, _initialConfig);\n    }\n\n    function initialize(\n        address _aclRoot,\n        ERC3000Data.Config memory _initialConfig\n    ) public initACL(_aclRoot) onlyInit(\"queue\") {\n        _setConfig(_initialConfig);\n        _registerStandard(type(IERC3000).interfaceId);\n    }\n\n    /**\n     * @notice Schedules an action for execution, allowing for challenges and vetos on a defined time window. Pulls collateral from submitter into contract.\n     * @param _container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\n     * the current configuration of the system\n     */\n    function schedule(\n        ERC3000Data.Container memory _container // TO FIX: Container is in memory and function has to be public to avoid an unestrutable solidity crash\n    )\n        public\n        override\n        auth(this.schedule.selector) // note that all functions in this contract are ACL protected (commonly some of them will be open for any addr to perform)\n        returns (bytes32 containerHash)\n    {\n        // prevent griefing by front-running (the same container is sent by two different people and one must be challenged)\n        // and ensure container hashes are unique\n        require(_container.payload.nonce == ++nonce, \"queue: bad nonce\");\n        // hash using ERC3000Data.hash(ERC3000Data.Config)\n        bytes32 _configHash = _container.config.hash();\n        // ensure that the hash of the config passed in the container matches the current config (implicit agreement approval by scheduler)\n        require(_configHash == configHash, \"queue: bad config\");\n        // ensure that the time delta to the execution timestamp provided in the payload is at least after the config's execution delay\n        require(\n            _container.payload.executionTime >=\n                _container.config.executionDelay.add(block.timestamp),\n            \"queue: bad delay\"\n        );\n        // ensure that the submitter of the payload is also the sender of this call\n        require(\n            _container.payload.submitter == msg.sender,\n            \"queue: bad submitter\"\n        );\n\n        containerHash = ERC3000Data.containerHash(\n            _container.payload.hash(),\n            _configHash\n        );\n        queue[containerHash].checkAndSetState(\n            GovernQueueStateLib.State.None, // ensure that the state for this container is None\n            GovernQueueStateLib.State.Scheduled // and if so perform a state transition to Scheduled\n        );\n        // we don't need to save any more state about the container in storage\n        // we just authenticate the hash and assign it a state, since all future\n        // actions regarding the container will need to provide it as a witness\n        // all witnesses are logged from this contract at least once, so the\n        // trust assumption should be the same as storing all on-chain (move complexity to clients)\n\n        ERC3000Data.Collateral memory collateral =\n            _container.config.scheduleDeposit;\n        collateral.collectFrom(_container.payload.submitter); // pull collateral from submitter (requires previous approval)\n\n        // the configured resolver may specify additional out-of-band payments for scheduling actions\n        // schedule() leaves these requirements up to the callers of `schedule()` or other users to fulfill\n\n        // emit an event to ensure data availability of all state that cannot be otherwise fetched (see how config isn't emitted since an observer should already have it)\n        emit Scheduled(containerHash, _container.payload);\n    }\n\n    /**\n     * @notice Executes an action after its execution delay has passed and its state hasn't been altered by a challenge or veto\n     * @param _container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\n     * the current configuration of the system\n     */\n    function execute(ERC3000Data.Container memory _container)\n        public\n        override\n        auth(this.execute.selector) // in most instances this will be open for any addr, but leaving configurable for flexibility\n        returns (bytes32 failureMap, bytes[] memory)\n    {\n        // ensure enough time has passed\n        require(\n            block.timestamp >= _container.payload.executionTime,\n            \"queue: wait more\"\n        );\n\n        bytes32 containerHash = _container.hash();\n        queue[containerHash].checkAndSetState(\n            GovernQueueStateLib.State.Scheduled, // note that we will revert here if the container wasn't previously scheduled\n            GovernQueueStateLib.State.Executed\n        );\n\n        _container.config.scheduleDeposit.releaseTo(\n            _container.payload.submitter\n        ); // release collateral to original submitter\n\n        return _execute(_container.payload, containerHash);\n    }\n\n    /**\n     * @notice Challenge a container in case its scheduling is illegal as per Config.rules. Pulls collateral and dispute fees from sender into contract\n     * @param _container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\n     * the current configuration of the system\n     * @param _reason Hint for case reviewers as to why the scheduled container is illegal\n     */\n    function challenge(\n        ERC3000Data.Container memory _container,\n        bytes memory _reason\n    )\n        public\n        override\n        auth(this.challenge.selector)\n        returns (uint256 disputeId)\n    {\n        bytes32 containerHash = _container.hash();\n        challengerCache[containerHash] = msg.sender; // cache challenger address while it is needed\n        queue[containerHash].checkAndSetState(\n            GovernQueueStateLib.State.Scheduled,\n            GovernQueueStateLib.State.Challenged\n        );\n\n        ERC3000Data.Collateral memory collateral =\n            _container.config.challengeDeposit;\n        collateral.collectFrom(msg.sender); // pull challenge collateral from sender\n\n        // create dispute on arbitrator\n        IArbitrator arbitrator = IArbitrator(_container.config.resolver);\n        (address recipient, ERC20 feeToken, uint256 feeAmount) =\n            arbitrator.getDisputeFees();\n        // @TODO: Fix\n        // require(\n        //     feeToken.safeTransferFrom(msg.sender, address(this), feeAmount),\n        //     \"queue: bad fee pull\"\n        // );\n        // @TODO: Fix\n        // require(\n        //     feeToken.safeApprove(recipient, feeAmount),\n        //     \"queue: bad approve\"\n        // );\n        disputeId = arbitrator.createDispute(2, abi.encode(_container)); // create dispute sending full container ABI encoded (could prob just send payload to save gas)\n        // @TODO: Fix\n        // require(feeToken.safeApprove(recipient, 0), \"queue: bad reset\"); // reset just in case non-compliant tokens (that fail on non-zero to non-zero approvals) are used\n\n        // submit both arguments as evidence and close evidence period. no more evidence can be submitted and a settlement can't happen (could happen off-protocol)\n        arbitrator.submitEvidence(\n            disputeId,\n            _container.payload.submitter,\n            _container.payload.proof\n        );\n        arbitrator.submitEvidence(disputeId, msg.sender, _reason);\n        arbitrator.closeEvidencePeriod(disputeId);\n\n        disputeItemCache[containerHash][arbitrator] = disputeId + 1; // cache a relation between disputeId and containerHash while needed\n\n        emit Challenged(\n            containerHash,\n            msg.sender,\n            _reason,\n            disputeId,\n            collateral\n        );\n    }\n\n    /**\n     * @notice Apply arbitrator's ruling over a challenge once it has come to a final ruling\n     * @param _container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\n     * the current configuration of the system\n     * @param _disputeId disputeId in the arbitrator in which the dispute over the container was created\n     */\n    function resolve(\n        ERC3000Data.Container memory _container,\n        uint256 _disputeId\n    ) public override returns (bytes32 failureMap, bytes[] memory) {\n        bytes32 containerHash = _container.hash();\n        IArbitrator arbitrator = IArbitrator(_container.config.resolver);\n\n        require(\n            disputeItemCache[containerHash][arbitrator] == _disputeId + 1,\n            \"queue: bad dispute id\"\n        );\n        delete disputeItemCache[containerHash][arbitrator]; // release state to refund gas; no longer needed in state\n\n        queue[containerHash].checkState(GovernQueueStateLib.State.Challenged);\n        (address subject, uint256 ruling) = arbitrator.rule(_disputeId);\n        require(subject == address(this), \"queue: not subject\");\n        bool arbitratorApproved = ruling == ALLOW_RULING;\n\n        queue[containerHash].setState(\n            arbitratorApproved\n                ? GovernQueueStateLib.State.Approved\n                : GovernQueueStateLib.State.Rejected\n        );\n\n        emit Resolved(containerHash, msg.sender, arbitratorApproved);\n        emit Ruled(arbitrator, _disputeId, ruling);\n\n        if (arbitratorApproved) {\n            return _executeApproved(_container);\n        } else {\n            return _settleRejection(_container);\n        }\n    }\n\n    function veto(ERC3000Data.Container memory _container, bytes memory _reason)\n        public\n        override\n        auth(this.veto.selector)\n    {\n        bytes32 containerHash = _container.hash();\n        GovernQueueStateLib.Item storage item = queue[containerHash];\n\n        if (item.state == GovernQueueStateLib.State.Challenged) {\n            item.checkAndSetState(\n                GovernQueueStateLib.State.Challenged,\n                GovernQueueStateLib.State.Cancelled\n            );\n\n            address challenger = challengerCache[containerHash];\n            // release state to refund gas; no longer needed in state\n            delete challengerCache[containerHash];\n            delete disputeItemCache[containerHash][\n                IArbitrator(_container.config.resolver)\n            ];\n\n            // release collateral to challenger and scheduler\n            _container.config.scheduleDeposit.releaseTo(\n                _container.payload.submitter\n            );\n            _container.config.challengeDeposit.releaseTo(challenger);\n        } else {\n            // If the given container doesn't have the state Challenged\n            // has it to be the Scheduled state and otherwise should it throw as expected\n            item.checkAndSetState(\n                GovernQueueStateLib.State.Scheduled,\n                GovernQueueStateLib.State.Cancelled\n            );\n\n            _container.config.scheduleDeposit.releaseTo(\n                _container.payload.submitter\n            );\n        }\n\n        emit Vetoed(containerHash, msg.sender, _reason);\n    }\n\n    /**\n     * @notice Apply a new configuration for all *new* containers to be scheduled\n     * @param _config A ERC3000Data.Config struct holding all the new params that will control the queue\n     */\n    function configure(ERC3000Data.Config memory _config)\n        public\n        override\n        auth(this.configure.selector)\n        returns (bytes32)\n    {\n        return _setConfig(_config);\n    }\n\n    // Internal\n\n    function _executeApproved(ERC3000Data.Container memory _container)\n        internal\n        returns (bytes32 failureMap, bytes[] memory)\n    {\n        bytes32 containerHash = _container.hash();\n        queue[containerHash].checkAndSetState(\n            GovernQueueStateLib.State.Approved,\n            GovernQueueStateLib.State.Executed\n        );\n\n        delete challengerCache[containerHash]; // release state to refund gas; no longer needed in state\n\n        // release all collateral to submitter\n        _container.config.scheduleDeposit.releaseTo(\n            _container.payload.submitter\n        );\n        _container.config.challengeDeposit.releaseTo(\n            _container.payload.submitter\n        );\n\n        return _execute(_container.payload, containerHash);\n    }\n\n    function _settleRejection(ERC3000Data.Container memory _container)\n        internal\n        returns (bytes32, bytes[] memory)\n    {\n        bytes32 containerHash = _container.hash();\n        queue[containerHash].checkAndSetState(\n            GovernQueueStateLib.State.Rejected,\n            GovernQueueStateLib.State.Cancelled\n        );\n\n        address challenger = challengerCache[containerHash];\n        delete challengerCache[containerHash]; // release state to refund gas; no longer needed in state\n\n        // release all collateral to challenger\n        _container.config.scheduleDeposit.releaseTo(challenger);\n        _container.config.challengeDeposit.releaseTo(challenger);\n\n        // return zero values as nothing is executed on rejection\n    }\n\n    function _execute(\n        ERC3000Data.Payload memory _payload,\n        bytes32 _containerHash\n    ) internal returns (bytes32, bytes[] memory) {\n        emit Executed(_containerHash, msg.sender);\n        return\n            _payload.executor.exec(\n                _payload.actions,\n                _payload.allowFailuresMap,\n                _containerHash\n            );\n    }\n\n    function _setConfig(ERC3000Data.Config memory _config)\n        internal\n        returns (bytes32)\n    {\n        configHash = _config.hash();\n\n        emit Configured(configHash, msg.sender, _config);\n\n        return configHash;\n    }\n}\n"
    },
    "contracts/govern/GovernRegistry.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\n\nimport \"./erc3k/IERC3000.sol\";\nimport \"./erc3k/IERC3000Executor.sol\";\nimport \"./erc3k/IERC3000Registry.sol\";\n\nimport \"@aragon/govern-contract-utils/contracts/erc165/ERC165.sol\";\n\ncontract GovernRegistry is IERC3000Registry {\n    mapping(string => bool) public nameUsed;\n\n    function register(\n        IERC3000Executor _executor,\n        IERC3000 _queue,\n        IERC20 _token,\n        string calldata _name,\n        bytes calldata _initialMetadata\n    ) override external\n    {\n        require(!nameUsed[_name], \"registry: name used\");\n\n        nameUsed[_name] = true;\n\n        emit Registered(_executor, _queue, _token, msg.sender, _name);\n        _setMetadata(_executor, _initialMetadata);\n    }\n\n    function setMetadata(bytes memory _metadata) override public {\n        _setMetadata(IERC3000Executor(msg.sender), _metadata);\n    }\n\n    function _setMetadata(IERC3000Executor _executor, bytes memory _metadata) internal {\n        emit SetMetadata(_executor, _metadata);\n    }\n}\n"
    },
    "contracts/govern/core-factories/GovernFactory.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity ^0.6.8;\n\nimport \"@aragon/govern-contract-utils/contracts/minimal-proxies/ERC1167ProxyFactory.sol\";\nimport \"@aragon/govern-contract-utils/contracts/address-utils/AddressUtils.sol\";\nimport \"../erc3k/IERC3000.sol\";\nimport \"../Govern.sol\";\n\ncontract GovernFactory {\n    using ERC1167ProxyFactory for address;\n    using AddressUtils for address;\n    \n    address public base;\n\n    constructor() public {\n        setupBase();\n    }\n\n    function newGovern(IERC3000 _initialExecutor, bytes32 _salt) public returns (Govern govern) {\n        if (_salt != bytes32(0)) {\n            return Govern(base.clone2(_salt, abi.encodeWithSelector(govern.initialize.selector, _initialExecutor)).toPayable());\n        } else {\n            return new Govern(address(_initialExecutor));\n        }\n    }\n\n    function setupBase() private {\n        base = address(new Govern(address(2)));\n    }\n}\n"
    },
    "contracts/govern/core-factories/GovernQueueFactory.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"@aragon/govern-contract-utils/contracts/minimal-proxies/ERC1167ProxyFactory.sol\";\n\nimport \"../pipelines/GovernQueue.sol\";\n\ncontract GovernQueueFactory {\n    using ERC1167ProxyFactory for address;\n\n    address public base;\n\n    constructor() public {\n        setupBase();\n    }\n\n    function newQueue(address _aclRoot, ERC3000Data.Config memory _config, bytes32 _salt) public returns (GovernQueue queue) {\n        if (_salt != bytes32(0)) {\n            return GovernQueue(base.clone2(_salt, abi.encodeWithSelector(queue.initialize.selector, _aclRoot, _config)));\n        } else {\n            return new GovernQueue(_aclRoot, _config);\n        }\n    }\n\n    function setupBase() private {\n        ERC3000Data.Collateral memory noCollateral;\n        ERC3000Data.Config memory config = ERC3000Data.Config(\n            0,\n            noCollateral,\n            noCollateral,\n            address(0),\n            \"\"\n        );\n        base = address(new GovernQueue(address(2), config));\n    }\n}\n"
    },
    "@aragon/govern-contract-utils/contracts/minimal-proxies/ERC1167ProxyFactory.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\n// Inspired by: https://github.com/optionality/clone-factory\n\npragma solidity ^0.6.8;\n\nlibrary ERC1167ProxyFactory {\n    function clone(address _implementation) internal returns (address cloneAddr) {\n        bytes memory code = generateCode(_implementation);\n\n        assembly {\n            cloneAddr := create(0, add(code, 0x20), 55)\n        }\n        \n        require(cloneAddr != address(0), \"proxy-factory: bad create\");\n    }\n\n    function clone(address _implementation, bytes memory _initData) internal returns (address cloneAddr) {\n        cloneAddr = clone(_implementation);\n        (bool ok, bytes memory ret) = cloneAddr.call(_initData);\n\n        require(ok, _getRevertMsg(ret));\n    }\n\n    function clone2(address _implementation, bytes32 _salt) internal returns (address cloneAddr) {\n        bytes memory code = generateCode(_implementation);\n        \n        assembly {\n            cloneAddr := create2(0, add(code, 0x20), 55, _salt)\n        }\n        \n        require(cloneAddr != address(0), \"proxy-factory: bad create2\");\n    }\n\n    function clone2(address _implementation, bytes32 _salt, bytes memory _initData) internal returns (address cloneAddr) {\n        cloneAddr = clone2(_implementation, _salt);\n        (bool ok, bytes memory ret) = cloneAddr.call(_initData);\n\n        require(ok, _getRevertMsg(ret));\n    }\n\n    function generateCode(address _implementation) internal pure returns (bytes memory code) {\n        code = new bytes(55);\n        \n        assembly {\n            mstore(add(code, 0x20), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(code, 0x34), shl(0x60, _implementation))\n            mstore(add(code, 0x48), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n        }\n    }\n\n    // From: https://ethereum.stackexchange.com/a/83577\n    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return '';\n\n        assembly {\n            _returnData := add(_returnData, 0x04) // Slice the sighash.\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n}\n"
    },
    "contracts/govern/erc3k/IERC3000Executor.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"./ERC3000Data.sol\";\n\nabstract contract IERC3000Executor {\n    bytes4 internal constant ERC3000_EXEC_INTERFACE_ID = this.exec.selector;\n\n    /**\n     * @notice Executes all given actions\n     * @param actions A array of ERC3000Data.Action for later executing those\n     * @param allowFailuresMap A map with the allowed failures\n     * @param memo The hash of the ERC3000Data.Container\n     * @return failureMap\n     * @return execResults\n     */\n    function exec(ERC3000Data.Action[] memory actions, bytes32 allowFailuresMap, bytes32 memo) virtual public returns (bytes32 failureMap, bytes[] memory execResults);\n    event Executed(address indexed actor, ERC3000Data.Action[] actions, bytes32 memo, bytes32 failureMap, bytes[] execResults);\n}\n"
    },
    "contracts/govern/govern-token/GovernToken.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity ^0.6.8;\n\nimport '@aragon/govern-contract-utils/contracts/initializable/Initializable.sol';\nimport '../../vocdoni/vendor/openzeppelin/math/SafeMath.sol';\n\nimport '../../vocdoni/vendor/openzeppelin/token/ERC20/IERC20.sol';\n\n// Copied and slightly modified from https://github.com/aragon/aragon-network-token/blob/v2-v1.0.0/packages/v2/contracts/token.sol\n// Lightweight token modelled after UNI-LP: https://github.com/Uniswap/uniswap-v2-core/blob/v1.0.1/contracts/UniswapV2ERC20.sol\n// Adds:\n//   - An exposed `mint()` with minting role\n//   - An exposed `burn()`\n//   - ERC-3009 (`transferWithAuthorization()`)\ncontract GovernToken is IERC20, Initializable {\n    using SafeMath for uint256;\n\n    // bytes32 private constant EIP712DOMAIN_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n    bytes32 private constant EIP712DOMAIN_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n    // bytes32 private constant VERSION_HASH = keccak256(\"1\")\n    bytes32 private constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    // bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH =\n    //     keccak256(\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\");\n    bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    address public minter;\n    uint256 override public totalSupply;\n    mapping (address => uint256) override public balanceOf;\n    mapping (address => mapping (address => uint256)) override public allowance;\n\n    // ERC-2612, ERC-3009 state\n    mapping (address => uint256) public nonces;\n    mapping (address => mapping (bytes32 => bool)) public authorizationState;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n    event ChangeMinter(address indexed minter);\n\n    modifier onlyMinter {\n        require(msg.sender == minter, \"token: not minter\");\n        _;\n    }\n\n    constructor(address _initialMinter, string memory _name, string memory _symbol, uint8 _decimals) public {\n        initialize(_initialMinter, _name, _symbol, _decimals);\n    }\n\n    function initialize(address _initialMinter, string memory _name, string memory _symbol, uint8 _decimals) public onlyInit(\"token\") {\n        _changeMinter(_initialMinter);\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    function _validateSignedData(address signer, bytes32 encodeData, uint8 v, bytes32 r, bytes32 s) internal view {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                getDomainSeparator(),\n                encodeData\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        // Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\n        require(recoveredAddress != address(0) && recoveredAddress == signer, \"token: bad sig\");\n    }\n\n    function _changeMinter(address newMinter) internal {\n        minter = newMinter;\n        emit ChangeMinter(newMinter);\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        // Balance is implicitly checked with SafeMath's underflow protection\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint256 value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint256 value) private {\n        require(to != address(this) && to != address(0), \"token: bad to\");\n\n        // Balance is implicitly checked with SafeMath's underflow protection\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function getChainId() public pure returns (uint256 chainId) {\n        assembly { chainId := chainid() }\n    }\n\n    function getDomainSeparator() public view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                EIP712DOMAIN_HASH,\n                keccak256(abi.encodePacked(name)),\n                VERSION_HASH,\n                getChainId(),\n                address(this)\n            )\n        );\n    }\n\n    function mint(address to, uint256 value) external onlyMinter returns (bool) {\n        _mint(to, value);\n        return true;\n    }\n\n    function changeMinter(address newMinter) external onlyMinter {\n        _changeMinter(newMinter);\n    }\n\n    function burn(uint256 value) external returns (bool) {\n        _burn(msg.sender, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) override external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) override external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) override external returns (bool) {\n        uint256 fromAllowance = allowance[from][msg.sender];\n        if (fromAllowance != uint256(-1)) {\n            // Allowance is implicitly checked with SafeMath's underflow protection\n            allowance[from][msg.sender] = fromAllowance.sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, \"token: auth expired\");\n\n        bytes32 encodeData = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        _validateSignedData(owner, encodeData, v, r, s);\n\n        _approve(owner, spender, value);\n    }\n\n    function transferWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n    {\n        require(block.timestamp > validAfter, \"token: auth wait\");\n        require(block.timestamp < validBefore, \"token: auth expired\");\n        require(!authorizationState[from][nonce],  \"token: auth used\");\n\n        bytes32 encodeData = keccak256(abi.encode(TRANSFER_WITH_AUTHORIZATION_TYPEHASH, from, to, value, validAfter, validBefore, nonce));\n        _validateSignedData(from, encodeData, v, r, s);\n\n        authorizationState[from][nonce] = true;\n        emit AuthorizationUsed(from, nonce);\n\n        _transfer(from, to, value);\n    }\n}\n"
    },
    "contracts/govern/govern-token/GovernMinter.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"@aragon/govern-contract-utils/contracts/acl/ACL.sol\";\nimport \"@aragon/govern-contract-utils/contracts/minimal-proxies/ERC1167ProxyFactory.sol\";\n\nimport \"./GovernToken.sol\";\nimport \"./MerkleDistributor.sol\";\n\ncontract GovernMinter is ACL {\n    using ERC1167ProxyFactory for address;\n\n    bytes4 constant internal MINT_ROLE =\n        this.mint.selector ^\n        this.merkleMint.selector\n    ;\n\n    GovernToken public token;\n    address public distributorBase;\n\n    event MintedSingle(address indexed to, uint256 amount, bytes context);\n    event MintedMerkle(address indexed distributor, bytes32 indexed merkleRoot, uint256 totalAmount, bytes tree, bytes context);\n\n    constructor(GovernToken _token, address _initialMinter, MerkleDistributor _distributorBase) ACL(_initialMinter) public {\n        initialize(_token, _initialMinter, _distributorBase);\n    }\n\n    function initialize(GovernToken _token, address _initialMinter, MerkleDistributor _distributorBase) public initACL(_initialMinter) onlyInit(\"minter\") {\n        token = _token;\n        distributorBase = address(_distributorBase);\n        _grant(MINT_ROLE, _initialMinter);\n    }\n\n    function mint(address _to, uint256 _amount, bytes calldata _context) external auth(MINT_ROLE) {\n        token.mint(_to, _amount);\n        emit MintedSingle(_to, _amount, _context);\n    }\n\n    function merkleMint(bytes32 _merkleRoot, uint256 _totalAmount, bytes calldata _tree, bytes calldata _context) external auth(MINT_ROLE) returns (MerkleDistributor distributor) {\n        address distributorAddr = distributorBase.clone(abi.encodeWithSelector(distributor.initialize.selector, token, _merkleRoot));\n        token.mint(distributorAddr, _totalAmount);\n\n        emit MintedMerkle(distributorAddr, _merkleRoot, _totalAmount, _tree, _context);\n\n        return MerkleDistributor(distributorAddr);\n    }\n\n    function eject(address _newMinter) external auth(this.eject.selector) {\n        token.changeMinter(_newMinter);\n    }\n}\n"
    },
    "contracts/govern/govern-token/MerkleDistributor.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\n// Copied and modified from: https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol\n\npragma solidity ^0.6.8;\n\nimport \"@openzeppelin/contracts/cryptography/MerkleProof.sol\";\n\nimport \"../../vocdoni/vendor/openzeppelin/token/ERC20/ERC20.sol\";\nimport \"../../vocdoni/vendor/openzeppelin/token/ERC20/SafeERC20.sol\";\nimport \"@aragon/govern-contract-utils/contracts/initializable/Initializable.sol\";\n\ncontract MerkleDistributor is Initializable {\n    \n    using SafeERC20 for ERC20;\n\n    ERC20 public token;\n    bytes32 public merkleRoot;\n\n    // This is a packed array of booleans.\n    mapping (uint256 => uint256) private claimedBitMap;\n\n    event Claimed(uint256 indexed index, address indexed to, uint256 amount);\n\n    constructor(ERC20 _token, bytes32 _merkleRoot) public {\n        initialize(_token, _merkleRoot);\n    }\n\n    function initialize(ERC20 _token, bytes32 _merkleRoot) public onlyInit(\"distributor\") {\n        token = _token;\n        merkleRoot = _merkleRoot;\n    }\n\n    function claim(uint256 _index, address _to, uint256 _amount, bytes32[] calldata _merkleProof) external {\n        require(!isClaimed(_index), \"dist: already claimed\");\n        require(_verifyBalanceOnTree(_index, _to, _amount, _merkleProof), \"dist: proof failed\");\n\n        _setClaimed(_index);\n        token.safeTransfer(_to, _amount);\n\n        emit Claimed(_index, _to, _amount);\n    }\n\n    function unclaimedBalance(uint256 _index, address _to, uint256 _amount, bytes32[] memory _proof) public view returns (uint256) {\n        if (isClaimed(_index)) return 0;\n        return _verifyBalanceOnTree(_index, _to, _amount, _proof) ? _amount : 0;\n    }\n\n    function _verifyBalanceOnTree(uint256 _index, address _to, uint256 _amount, bytes32[] memory _proof) internal view returns (bool) {\n        bytes32 node = keccak256(abi.encodePacked(_index, _to, _amount));\n        return MerkleProof.verify(_proof, merkleRoot, node);\n    }\n\n    function isClaimed(uint256 _index) public view returns (bool) {\n        uint256 claimedWord_index = _index / 256;\n        uint256 claimedBit_index = _index % 256;\n        uint256 claimedWord = claimedBitMap[claimedWord_index];\n        uint256 mask = (1 << claimedBit_index);\n        return claimedWord & mask == mask;\n    }\n\n    function _setClaimed(uint256 _index) private {\n        uint256 claimedWord_index = _index / 256;\n        uint256 claimedBit_index = _index % 256;\n        claimedBitMap[claimedWord_index] = claimedBitMap[claimedWord_index] | (1 << claimedBit_index);\n    }\n}"
    },
    "contracts/govern/erc3k/ERC3000Data.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"./IERC3000Executor.sol\";\n\nlibrary ERC3000Data {\n    // TODO: come up with a non-shitty name\n    struct Container {\n        Payload payload;\n        Config config;\n    }\n\n    // WARN: Always remember to change the 'hash' function if modifying the struct\n    struct Payload {\n        uint256 nonce;\n        uint256 executionTime;\n        address submitter;\n        IERC3000Executor executor;\n        Action[] actions;\n        bytes32 allowFailuresMap;\n        bytes proof;\n    }\n\n    struct Action {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n\n    struct Config {\n        uint256 executionDelay;\n        Collateral scheduleDeposit;\n        Collateral challengeDeposit;\n        address resolver;\n        bytes rules;\n    }\n\n    struct Collateral {\n        address token;\n        uint256 amount;\n    }\n\n    function containerHash(bytes32 payloadHash, bytes32 configHash) internal view returns (bytes32) {\n        uint chainId;\n        assembly {\n            chainId := chainid()\n        }\n\n        return keccak256(abi.encodePacked(\"erc3k-v1\", address(this), chainId, payloadHash, configHash));\n    }\n\n    function hash(Container memory container) internal view returns (bytes32) {\n        return containerHash(hash(container.payload), hash(container.config));\n    }\n\n    function hash(Payload memory payload) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                payload.nonce,\n                payload.executionTime,\n                payload.submitter,\n                payload.executor,\n                keccak256(abi.encode(payload.actions)),\n                payload.allowFailuresMap,\n                keccak256(payload.proof)\n            )\n        );\n    }\n\n    function hash(Config memory config) internal pure returns (bytes32) {\n        return keccak256(abi.encode(config));\n    }\n}\n"
    },
    "@aragon/govern-contract-utils/contracts/initializable/Initializable.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity 0.6.8;\n\ncontract Initializable {\n    mapping (string => uint256) public initBlocks;\n\n    event Initialized(string indexed key);\n\n    modifier onlyInit(string memory key) {\n        require(initBlocks[key] == 0, \"initializable: already initialized\");\n        initBlocks[key] = block.number;\n        _;\n        emit Initialized(key);\n    }\n}"
    },
    "contracts/vocdoni/vendor/openzeppelin/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@aragon/govern-contract-utils/contracts/acl/ACL.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"../initializable/Initializable.sol\";\n\nimport \"./IACLOracle.sol\";\n\nlibrary ACLData {\n    enum BulkOp { Grant, Revoke, Freeze }\n\n    struct BulkItem {\n        BulkOp op;\n        bytes4 role;\n        address who;\n    }\n}\n\ncontract ACL is Initializable {\n    bytes4 public constant ROOT_ROLE =\n        this.grant.selector\n        ^ this.revoke.selector\n        ^ this.freeze.selector\n        ^ this.bulk.selector\n    ;\n\n    address internal constant FREEZE_FLAG = address(1);\n    address internal constant ANY_ADDR = address(-1);\n\n    address internal constant UNSET_ROLE = address(0);\n    address internal constant ALLOW_FLAG = address(2);\n    \n    mapping (bytes4 => mapping (address => address)) public roles;\n\n    event Granted(bytes4 indexed role, address indexed actor, address indexed who, IACLOracle oracle);\n    event Revoked(bytes4 indexed role, address indexed actor, address indexed who);\n    event Frozen(bytes4 indexed role, address indexed actor);\n\n    modifier auth(bytes4 _role) {\n        require(willPerform(_role, msg.sender, msg.data), \"acl: auth\");\n        _;\n    }\n\n    modifier initACL(address _initialRoot) {\n        // ACL might have been already initialized by constructors\n        if (initBlocks[\"acl\"] == 0) {\n            _initializeACL(_initialRoot);\n        }\n        _;\n    }\n\n    constructor(address _initialRoot) public initACL(_initialRoot) { }\n\n    function _initializeACL(address _initialRoot) internal onlyInit(\"acl\") {\n        _grant(ROOT_ROLE, _initialRoot);\n    }\n\n    function grant(bytes4 _role, address _who) external auth(ROOT_ROLE) {\n        _grant(_role, _who);\n    }\n\n    function grantWithOracle(bytes4 _role, address _who, IACLOracle _oracle) external auth(ROOT_ROLE) {\n        _grantWithOracle(_role, _who, _oracle);\n    }\n\n    function revoke(bytes4 _role, address _who) external auth(ROOT_ROLE) {\n        _revoke(_role, _who);\n    }\n\n    function freeze(bytes4 _role) external auth(ROOT_ROLE) {\n        _freeze(_role);\n    }\n\n    function bulk(ACLData.BulkItem[] memory items) public auth(ROOT_ROLE) {\n        for (uint256 i = 0; i < items.length; i++) {\n            ACLData.BulkItem memory item = items[i];\n\n            if (item.op == ACLData.BulkOp.Grant) _grant(item.role, item.who);\n            else if (item.op == ACLData.BulkOp.Revoke) _revoke(item.role, item.who);\n            else if (item.op == ACLData.BulkOp.Freeze) _freeze(item.role);\n        }\n    }\n\n    function willPerform(bytes4 _role, address _sender, bytes memory _data) public returns (bool) {\n        address senderRole = roles[_role][msg.sender];\n        if (senderRole != UNSET_ROLE) {\n            if (senderRole == ALLOW_FLAG) return true;\n            if (IACLOracle(senderRole).willPerform(_role, _sender, _data)) return true;\n        }\n\n        address anyRole = roles[_role][ANY_ADDR];\n        if (anyRole != UNSET_ROLE) {\n            if (anyRole == ALLOW_FLAG) return true;\n            if (IACLOracle(anyRole).willPerform(_role, _sender, _data)) return true;\n        }\n\n        return false;\n    }\n\n    function _grant(bytes4 _role, address _who) internal {\n        _grantWithOracle(_role, _who, IACLOracle(ALLOW_FLAG));\n    }\n\n    function _grantWithOracle(bytes4 _role, address _who, IACLOracle _oracle) internal {\n        require(!isFrozen(_role), \"acl: frozen\");\n        require(_who != FREEZE_FLAG, \"acl: bad freeze\");\n        \n        roles[_role][_who] = address(_oracle);\n        emit Granted(_role, msg.sender, _who, _oracle);\n    }\n\n    function _revoke(bytes4 _role, address _who) internal {\n        require(!isFrozen(_role), \"acl: frozen\");\n\n        roles[_role][_who] = UNSET_ROLE;\n        emit Revoked(_role, msg.sender, _who);\n    }\n\n    function _freeze(bytes4 _role) internal {\n        require(!isFrozen(_role), \"acl: frozen\");\n\n        roles[_role][FREEZE_FLAG] = FREEZE_FLAG;\n\n        emit Frozen(_role, msg.sender);\n    }\n\n    function isFrozen(bytes4 _role) public view returns (bool) {\n        return roles[_role][FREEZE_FLAG] == FREEZE_FLAG;\n    }\n}"
    },
    "@aragon/govern-contract-utils/contracts/acl/IACLOracle.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity 0.6.8;\n\ninterface IACLOracle {\n    function willPerform(bytes4 role, address who, bytes calldata data) external returns (bool allowed);\n}"
    },
    "@openzeppelin/contracts/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle trees (hash trees),\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n"
    },
    "contracts/vocdoni/vendor/openzeppelin/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/vocdoni/vendor/openzeppelin/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../math/SafeMath.sol\";\nimport \"./IERC20.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/vocdoni/vendor/openzeppelin/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/vocdoni/vendor/openzeppelin/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@aragon/govern-contract-utils/contracts/adaptative-erc165/AdaptativeERC165.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.6.8;\n\nimport \"../erc165/ERC165.sol\";\n\ncontract AdaptativeERC165 is ERC165 {\n    // erc165 interface ID -> whether it is supported\n    mapping (bytes4 => bool) internal standardSupported;\n    // callback function signature -> magic number to return\n    mapping (bytes4 => bytes32) internal callbackMagicNumbers;\n\n    bytes32 internal constant UNREGISTERED_CALLBACK = bytes32(0);\n\n    event RegisteredStandard(bytes4 interfaceId);\n    event RegisteredCallback(bytes4 sig, bytes4 magicNumber);\n    event ReceivedCallback(bytes4 indexed sig, bytes data);\n\n    function supportsInterface(bytes4 _interfaceId) override virtual public view returns (bool) {\n        return standardSupported[_interfaceId] || super.supportsInterface(_interfaceId);\n    }\n\n    function _handleCallback(bytes4 _sig, bytes memory _data) internal {\n        bytes32 magicNumber = callbackMagicNumbers[_sig];\n        require(magicNumber != UNREGISTERED_CALLBACK, \"adap-erc165: unknown callback\");\n\n        emit ReceivedCallback(_sig, _data);\n\n        // low-level return magic number\n        assembly {\n            mstore(0x00, magicNumber)\n            return(0x00, 0x20)\n        }\n    }\n\n    function _registerStandardAndCallback(bytes4 _interfaceId, bytes4 _callbackSig, bytes4 _magicNumber) internal {\n        _registerStandard(_interfaceId);\n        _registerCallback(_callbackSig, _magicNumber);\n    }\n\n    function _registerStandard(bytes4 _interfaceId) internal {\n        // use a random magic number for standards without number\n        standardSupported[_interfaceId] = true;\n\n        emit RegisteredStandard(_interfaceId);\n    }\n\n    function _registerCallback(bytes4 _callbackSig, bytes4 _magicNumber) internal {\n        callbackMagicNumbers[_callbackSig] = _magicNumber;\n\n        emit RegisteredCallback(_callbackSig, _magicNumber);\n    }\n}"
    },
    "contracts/govern/erc3k/IERC3000.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"./ERC3000Data.sol\";\n\nabstract contract IERC3000 {\n    /**\n     * @notice Schedules an action for execution, allowing for challenges and vetos on a defined time window\n     * @param container A Container struct holding both the payload being scheduled for execution and\n     * the current configuration of the system\n     * @return containerHash\n     */\n    function schedule(ERC3000Data.Container memory container) virtual public returns (bytes32 containerHash);\n    event Scheduled(bytes32 indexed containerHash, ERC3000Data.Payload payload);\n\n    /**\n     * @notice Executes an action after its execution delay has passed and its state hasn't been altered by a challenge or veto\n     * @param container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\n     * the current configuration of the system\n     * MUST be an ERC3000Executor call: payload.executor.exec(payload.actions)\n     * @return failureMap\n     * @return execResults\n     */\n    function execute(ERC3000Data.Container memory container) virtual public returns (bytes32 failureMap, bytes[] memory execResults);\n    event Executed(bytes32 indexed containerHash, address indexed actor);\n\n    /**\n     * @notice Challenge a container in case its scheduling is illegal as per Config.rules. Pulls collateral and dispute fees from sender into contract\n     * @param container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\n     * the current configuration of the system\n     * @param reason Hint for case reviewers as to why the scheduled container is illegal\n     * @return resolverId\n     */\n    function challenge(ERC3000Data.Container memory container, bytes memory reason) virtual public returns (uint256 resolverId);\n    event Challenged(bytes32 indexed containerHash, address indexed actor, bytes reason, uint256 resolverId, ERC3000Data.Collateral collateral);\n\n    /**\n     * @notice Apply arbitrator's ruling over a challenge once it has come to a final ruling\n     * @param container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\n     * the current configuration of the system\n     * @param resolverId disputeId in the arbitrator in which the dispute over the container was created\n     * @return failureMap\n     * @return execResults\n     */\n    function resolve(ERC3000Data.Container memory container, uint256 resolverId) virtual public returns (bytes32 failureMap, bytes[] memory execResults);\n    event Resolved(bytes32 indexed containerHash, address indexed actor, bool approved);\n\n    /**\n     * @notice Apply arbitrator's ruling over a challenge once it has come to a final ruling\n     * @param container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\n     * the current configuration of the system\n     * @param reason Justification for the veto\n     */\n    function veto(ERC3000Data.Container memory container, bytes memory reason) virtual public;\n    event Vetoed(bytes32 indexed containerHash, address indexed actor, bytes reason);\n\n    /**\n     * @notice Apply a new configuration for all *new* containers to be scheduled\n     * @param config A ERC3000Data.Config struct holding all the new params that will control the system\n     * @return configHash\n     */\n    function configure(ERC3000Data.Config memory config) virtual public returns (bytes32 configHash);\n    event Configured(bytes32 indexed configHash, address indexed actor, ERC3000Data.Config config);\n}\n"
    },
    "contracts/govern/protocol/IArbitrable.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\n// From https://github.com/aragon/protocol/blob/f1b3361a160da92b9bb449c0a05dee0c30e41594/packages/evm/contracts/arbitration/IArbitrable.sol\n\npragma solidity ^0.6.8;\n\nimport \"./IArbitrator.sol\";\n\n/**\n* @dev The Arbitrable instances actually don't require to follow any specific interface.\n*      Note that this is actually optional, although it does allow the Protocol to at least have a way to identify a specific set of instances.\n*/\nabstract contract IArbitrable {\n    /**\n    * @dev Emitted when an IArbitrable instance's dispute is ruled by an IArbitrator\n    * @param arbitrator IArbitrator instance ruling the dispute\n    * @param disputeId Identification number of the dispute being ruled by the arbitrator\n    * @param ruling Ruling given by the arbitrator\n    */\n    event Ruled(IArbitrator indexed arbitrator, uint256 indexed disputeId, uint256 ruling);\n}\n"
    },
    "contracts/govern/protocol/IArbitrator.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\n// From https://github.com/aragon/protocol/blob/f1b3361a160da92b9bb449c0a05dee0c30e41594/packages/evm/contracts/arbitration/IArbitrator.sol\n\npragma solidity ^0.6.8;\n\nimport \"../../vocdoni/vendor/openzeppelin/token/ERC20/SafeERC20.sol\";\nimport \"../../vocdoni/vendor/openzeppelin/token/ERC20/ERC20.sol\";\n\n\ninterface IArbitrator {\n    /**\n    * @dev Create a dispute over the Arbitrable sender with a number of possible rulings\n    * @param _possibleRulings Number of possible rulings allowed for the dispute\n    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\n    * @return Dispute identification number\n    */\n    function createDispute(uint256 _possibleRulings, bytes calldata _metadata) external returns (uint256);\n\n    /**\n    * @dev Submit evidence for a dispute\n    * @param _disputeId Id of the dispute in the Protocol\n    * @param _submitter Address of the account submitting the evidence\n    * @param _evidence Data submitted for the evidence related to the dispute\n    */\n    function submitEvidence(uint256 _disputeId, address _submitter, bytes calldata _evidence) external;\n\n    /**\n    * @dev Close the evidence period of a dispute\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\n    */\n    function closeEvidencePeriod(uint256 _disputeId) external;\n\n    /**\n    * @notice Rule dispute #`_disputeId` if ready\n    * @param _disputeId Identification number of the dispute to be ruled\n    * @return subject Subject associated to the dispute\n    * @return ruling Ruling number computed for the given dispute\n    */\n    function rule(uint256 _disputeId) external returns (address subject, uint256 ruling);\n\n    /**\n    * @dev Tell the dispute fees information to create a dispute\n    * @return recipient Address where the corresponding dispute fees must be transferred to\n    * @return feeToken ERC20 token used for the fees\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\n    */\n    function getDisputeFees() external view returns (address recipient, ERC20 feeToken, uint256 feeAmount);\n\n    /**\n    * @dev Tell the payments recipient address\n    * @return Address of the payments recipient module\n    */\n    function getPaymentsRecipient() external view returns (address);\n}\n"
    },
    "contracts/govern/utils/DepositLib.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.6.8;\n\nimport \"../erc3k/ERC3000Data.sol\";\n\nimport \"../../vocdoni/vendor/openzeppelin/token/ERC20/ERC20.sol\";\nimport \"../../vocdoni/vendor/openzeppelin/token/ERC20/SafeERC20.sol\";\n\nlibrary DepositLib {\n    using SafeERC20 for ERC20;\n\n    event Locked(address indexed token, address indexed from, uint256 amount);\n    event Unlocked(address indexed token, address indexed to, uint256 amount);\n\n    function collectFrom(ERC3000Data.Collateral memory _collateral, address _from) internal {\n        if (_collateral.amount > 0) {\n            ERC20 token = ERC20(_collateral.token);\n            //@TODO: Fix\n            // require(token.safeTransferFrom(_from, address(this), _collateral.amount), \"deposit: bad token lock\");\n\n            emit Locked(_collateral.token, _from, _collateral.amount);\n        }\n    }\n\n    function releaseTo(ERC3000Data.Collateral memory _collateral, address _to) internal {\n        if (_collateral.amount > 0) {\n            ERC20 token = ERC20(_collateral.token);\n            //@TODO: Fix\n            // require(token.safeTransfer(_to, _collateral.amount), \"deposit: bad token release\");\n\n            emit Unlocked(_collateral.token, _to, _collateral.amount);\n        }\n    }\n}\n"
    },
    "@aragon/govern-contract-utils/contracts/erc165/ERC165.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.6.8;\n\nabstract contract ERC165 {\n    // Includes supportsInterface method:\n    bytes4 internal constant ERC165_INTERFACE_ID = bytes4(0x01ffc9a7);\n\n    /**\n    * @dev Query if a contract implements a certain interface\n    * @param _interfaceId The interface identifier being queried, as specified in ERC-165\n    * @return True if the contract implements the requested interface and if its not 0xffffffff, false otherwise\n    */\n    function supportsInterface(bytes4 _interfaceId) virtual public view returns (bool) {\n        return _interfaceId == ERC165_INTERFACE_ID\n          || block.timestamp == 1; // silence visibility warning needed for overrides\n    }\n}"
    },
    "contracts/govern/erc3k/IERC3000Registry.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity 0.6.8;\n\nimport \"./IERC3000.sol\";\nimport \"./IERC3000Executor.sol\";\n\nimport \"../../vocdoni/vendor/openzeppelin/token/ERC20/IERC20.sol\";\n\nabstract contract IERC3000Registry {\n    /**\n     * @notice Registers a IERC3000Executor and IERC3000 contract by a name and with his metadata\n     * @param executor IERC3000Executor contract\n     * @param queue IERC3000 contract\n     * @param name The name of this DAO\n     * @param token Governance token of the DAO\n     * @param initialMetadata Additional data to store for this DAO\n     */\n    function register(IERC3000Executor executor, IERC3000 queue, IERC20 token, string calldata name, bytes calldata initialMetadata) virtual external;\n    event Registered(IERC3000Executor indexed executor, IERC3000 queue, IERC20 indexed token, address indexed registrant, string name);\n\n    /**\n     * @notice Sets or updates the metadata of a DAO\n     * @param metadata Additional data to store for this DAO\n     */\n    function setMetadata(bytes memory metadata) virtual public;\n    event SetMetadata(IERC3000Executor indexed executor, bytes metadata);\n}\n"
    },
    "@aragon/govern-contract-utils/contracts/address-utils/AddressUtils.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.6.8;\n\nlibrary AddressUtils {\n    function toPayable(address addr) internal pure returns (address payable) {\n        return address(bytes20(addr));\n    }\n\n    function toAddress(address addr) internal pure returns (address payable) {\n        return address(bytes20(addr));\n    }\n\n    function isContract(address addr) internal view returns (bool result) {\n        assembly {\n            result := not(iszero(extcodesize(addr)))\n        }\n    }\n}"
    },
    "contracts/govern/Govern.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\n\nimport \"@aragon/govern-contract-utils/contracts/acl/ACL.sol\";\nimport \"@aragon/govern-contract-utils/contracts/adaptative-erc165/AdaptativeERC165.sol\";\nimport \"@aragon/govern-contract-utils/contracts/bitmaps/BitmapLib.sol\";\n\nimport \"./erc3k/IERC3000.sol\";\nimport \"./erc3k/IERC3000Executor.sol\";\nimport \"./erc1271/ERC1271.sol\";\n\ncontract Govern is IERC3000Executor, AdaptativeERC165, ERC1271, ACL {\n    using BitmapLib for bytes32;\n\n    bytes4 internal constant EXEC_ROLE = this.exec.selector;\n    bytes4 internal constant REGISTER_STANDARD_ROLE = this.registerStandardAndCallback.selector;\n    bytes4 internal constant SET_SIGNATURE_VALIDATOR_ROLE = this.setSignatureValidator.selector;\n    uint256 internal constant MAX_ACTIONS = 256;\n\n    ERC1271 signatureValidator;\n\n    event ETHDeposited(address indexed sender, uint256 value);\n\n    constructor(address _initialExecutor) ACL(address(this)) public {\n        initialize(_initialExecutor);\n    }\n\n    function initialize(address _initialExecutor) public initACL(address(this)) onlyInit(\"govern\") {\n        _grant(EXEC_ROLE, address(_initialExecutor));\n        _grant(REGISTER_STANDARD_ROLE, address(this));\n        _grant(SET_SIGNATURE_VALIDATOR_ROLE, address(this));\n\n        _registerStandard(ERC3000_EXEC_INTERFACE_ID);\n        _registerStandard(type(ERC1271).interfaceId);\n    }\n\n    receive () external payable {\n        emit ETHDeposited(msg.sender, msg.value);\n    }\n\n    fallback () external {\n        _handleCallback(msg.sig, msg.data); // WARN: does a low-level return, any code below would be unreacheable\n    }\n\n    function exec(ERC3000Data.Action[] memory actions, bytes32 allowFailuresMap, bytes32 memo) override public auth(EXEC_ROLE) returns (bytes32, bytes[] memory) {\n        require(actions.length <= MAX_ACTIONS, \"govern: too many\"); // need to limit since we use 256-bit bitmaps\n\n        bytes[] memory execResults = new bytes[](actions.length);\n        bytes32 failureMap = BitmapLib.empty; // start with an empty bitmap\n\n        for (uint256 i = 0; i < actions.length; i++) {\n            // TODO: optimize with assembly\n            (bool ok, bytes memory ret) = actions[i].to.call{value: actions[i].value}(actions[i].data);\n            require(ok || allowFailuresMap.get(uint8(i)), \"govern: call\");\n            // if a call fails, flip that bit to signal failure\n            failureMap = ok ? failureMap : failureMap.flip(uint8(i));\n            execResults[i] = ret;\n        }\n\n        emit Executed(msg.sender, actions, memo, failureMap, execResults);\n\n        return (failureMap, execResults);\n    }\n\n    function registerStandardAndCallback(bytes4 _interfaceId, bytes4 _callbackSig, bytes4 _magicNumber) external auth(REGISTER_STANDARD_ROLE) {\n        _registerStandardAndCallback(_interfaceId, _callbackSig, _magicNumber);\n    }\n\n    function setSignatureValidator(ERC1271 _signatureValidator) external auth(SET_SIGNATURE_VALIDATOR_ROLE) {\n        signatureValidator = _signatureValidator;\n    }\n\n    function isValidSignature(bytes32 _hash, bytes memory _signature) override public view returns (bytes4) {\n        if (address(signatureValidator) == address(0)) return bytes4(0); // invalid magic number\n        return signatureValidator.isValidSignature(_hash, _signature); // forward call to set validation contract\n    }\n}\n"
    },
    "@aragon/govern-contract-utils/contracts/bitmaps/BitmapLib.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\n\nlibrary BitmapLib {\n    bytes32 constant internal empty = bytes32(0);\n    bytes32 constant internal allowAll = empty;\n    bytes32 constant internal denyAll = bytes32(uint256(-1));\n\n    function flip(bytes32 map, uint8 index) internal pure returns (bytes32) {\n        return bytes32(uint256(map) ^ uint256(1) << index);\n    }\n\n    function get(bytes32 map, uint8 index) internal pure returns (bool) {\n        return bool(uint256(map) >> index & 1 == 1);\n    }\n}\n"
    },
    "contracts/govern/erc1271/ERC1271.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.6.8;\n\n/**\n* @title ERC1271 interface\n* @dev see https://eips.ethereum.org/EIPS/eip-1271\n*/\nabstract contract ERC1271 {\n    // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n    bytes4 constant internal MAGICVALUE = 0x1626ba7e;\n\n    /**\n    * @dev Should return whether the signature provided is valid for the provided data\n    * @param _hash Keccak256 hash of arbitrary length data signed on the behalf of address(this)\n    * @param _signature Signature byte array associated with _data\n    *\n    * MUST return the bytes4 magic value 0x1626ba7e when function passes.\n    * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n    * MUST allow external calls\n    */\n    function isValidSignature(bytes32 _hash, bytes memory _signature) virtual public view returns (bytes4 magicValue);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}